-- TODO: check that default values are the correct type and not nil after initialise

local floor, insert = math.floor, table.insert

local parsed, fileEnvironments = loadfile( "parse" )( "Small.luo" )
print("Starting compile...")
local file = ""

local function addInclude(name)
	local h = io.open("includes/" .. name, "r")
	if h then
		file = file .. h:read("*all")
		h:close()
	end
end

local function add(str, ...)
	file = file .. string.format(str, ...)
end

-- escape square brackets
local function escapeSquare(str)
	return str:gsub("%[(=*)%[", "[%1=["):gsub("%](=*)%]", "]%1=]")
end

local idN = 1
local idPrefix = "__CLASS__"
local idChars = {"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"}
local idCharsLength = #idChars
local function nextID()
	local id = ""
	local rem = idN
	while rem > 0 do
		id = idChars[(rem - 1) % idCharsLength + 1] .. id
		rem = floor((rem - 1) / idCharsLength)
	end
	idN = idN + 1
	return idPrefix .. id
end

local function addFunction(str, ...)
	local functionID = nextID()
	add("local function %s%s ", functionID, string.format(str, ...))
	return functionID
end

-- first add all the built in functions

-- local lineNumberMap = {}
-- local function addLineNumber(funcID, file, startLine)
-- 	insert(lineNumberMap
-- end

local functionErrorID = addFunction([[(m)error(m,3)end]])

local functionErrorIDs = {
	metatable = {
		class = {
			index = addFunction([[(_,k)%s("attempted to access non-existant enum '"..k.."' of class '"..tostring(_).."'")end]], functionErrorID),
			newindex = addFunction([[(_,k,v)%s("attempted to mutate class '"..tostring(_).."' using key '"..k.."'")end]], functionErrorID)
		},
		instance = {
			index = addFunction([[(_,k)%s("attempted to access non-existant property '"..k.."' of '"..tostring(_).."'")end]], functionErrorID),
			newindex = addFunction([[(_,k,v)%s("attempted to set non-existant property '"..k.."' of '"..tostring(_).."' to '"..v.."'")end]], functionErrorID)
		},
		func = {
			newindex = addFunction([[(_,k,v)%s("attempted to set value of function '"..k.."' of '"..tostring(_).."' to '"..v.."'")end]], functionErrorID)
		},
		enum = {
			index = addFunction([[(_,k)%s("attempted to access non-existant key '"..k.."' from enum '"..tostring(_).."'")end]], functionErrorID),
			newindex = addFunction([[(_,k,v)%s("attempted to mutate enum '"..tostring(_).."' key '"..tostring(k).."' to '"..v.."'")end]], functionErrorID)
		},
		super = {
			index = addFunction([[(_,k)if k=="super"then %s("tried to access super of '" .. tostring(_) .. "', which does not have a super")else %s("attempted to access invalid index '" .. k .. "' of super '" .. tostring(_) .. "'")end end]], functionErrorID, functionErrorID),
			newindex = addFunction([[(_,k,v)%s("attempted to mutate super '"..tostring(_).."' using key '"..k.."'")end]], functionErrorID)
		},
	},
	readOnly = addFunction([[(_,k,v)%s("attempted to set read only property '"..k.."' of '"..tostring(_).."' to '"..v.."'")end]], functionErrorID),
	type = {
		property = addFunction([[(_,k,t,v)%s("attempted to set property '"..k.."' of '"..tostring(_).."' to an invalid value '"..tostring(v).."', expected '"..t.."'")end]], functionErrorID),
		parameter = addFunction([[(_,k,f,t,v)%s("attempted to pass parameter '"..k.."' of '"..tostring(_).."."..f.."' an invalid value '"..tostring(v).."', expected '"..t.."'")end]], functionErrorID),
	}
}

local functionTypeCheckIDs = {
	String = addFunction([[(v)return v==nil or type(v)~="string"end]])
}

local functionExecuteID = addFunction([[(f,e,...)return setfenv(f, e)(...)end]])

-- TODO: minify when it 100% works
local functionErrorProxyID = addFunction([[(name, startLine, func)
	return select(2, xpcall(func,  function(err)
		local _, trace = pcall(error, "<@", 3)
		local lineNumber = trace:match(":(%%d+): <@")
		if not lineNumber then print(err)
		else
			print(name .. ":" .. lineNumber + startLine - 1 .. ": " .. err:match(":" .. lineNumber .. ": (.*)$"))
		end
	end))
end]])

addInclude("top")

-- now add the file environments
local fileEnvironmentIDs = {}
for i, blocks in ipairs(fileEnvironments) do
	local id = nextID()
	fileEnvironmentIDs[i] = id
	add("local %s=setmetatable({},{__index=_G})", id)
end

-- figure out the order that the classes need to be loaded (supers first)
local classOrder = {}
local orderedClasses = {}
local function addClassOrder(className, classDetails)
	-- don't add a class that's already loaded
	if not orderedClasses[className] then
		-- if the class has a super we need to place this AFTER the super
		if classDetails.extends then
			if not orderedClasses[classDetails.extends] then
				-- the super hasn't been added yet, do that now
				addClassOrder(classDetails.extends, parsed[classDetails.extends])
			end
		end
		-- the super has been added to the list or there isn't one, we can simply add ourself to the end
		insert(classOrder, classDetails)
		orderedClasses[className] = true
	end
end
for className, classDetails in pairs(parsed) do
	addClassOrder(className, classDetails)
end

-- now create empty tables for all the classes and their statics (which are filled later on) so we can reference them directly when needed
local classStaticIDs = {}
local classTostringIDs = {}
for className, _ in pairs(parsed) do
	-- TODO: maybe add an option which makes these locals?
	add("%s={}", className)
	local tostringID = nextID()
	add("local %s=\"class '%s': \"..tostring(%s):sub(8)", tostringID, className, className)
	classTostringIDs[className] = tostringID
	local staticID = nextID()
	classStaticIDs[className] = staticID
	add("local %s={}", staticID)
end

-- the blank __index and __newindex functions for properties
local functionBlankIndexID = nextID()
add("local function %s(_,k,v)return v[k] end ", functionBlankIndexID)
local functionBlankNewindexID = nextID()
add("local function %s(_,k,n,v)v[k]=n end ", functionBlankNewindexID)

local classMetatableMetatableID = nextID()
add("local %s={__index=%s,__newindex=%s}", classMetatableMetatableID, functionErrorIDs.metatable.class.index, functionErrorIDs.metatable.class.newindex)
local instanceMetatableMetatableID = nextID()
add("local %s={__index=%s,__newindex=%s}", instanceMetatableMetatableID, functionErrorIDs.metatable.instance.index, functionErrorIDs.metatable.instance.newindex)

-- now create each class one by one
for i, classDetails in pairs(classOrder) do
	-- create the tree of super details
	local className = classDetails.className
	print("Loading class: " .. className)
	local supersDetails = {classDetails}
	local nextSuperName = classDetails.extends
	local previousSuperName = className
	while nextSuperName do
		local superDetails = parsed[nextSuperName]
		if not superDetails then
			error("compile error: unable to find class '" .. nextSuperName .. "' to extend class '" .. previousSuperName .. "' from")
		end
		table.insert(supersDetails, superDetails)
		previousSuperName = nextSuperName
		nextSuperName = superDetails.extends
	end

	-- create the enums
	local enumIDs = {}
	local enumTostringIDs = {}
	local enumTypeCheckIDs = {}
	for enumName, content in pairs(classDetails.enums) do
		-- create enum's value table
		local enumID = nextID()
		enumIDs[enumName] = enumID
		local enumTostringID = nextID()
		enumTostringIDs[enumName] = enumTostringID
		add("local %s=%s", enumID, content.values)
		add("local %s=\"enum '%s.%s': \" .. tostring(%s):sub(8)", enumTostringID, className, enumName, enumID)
		-- create the type checking function
		-- TODO: enum type check function
		-- local enumTypeCheckID = nextID()
		-- add("__CLASS__")
	end

	-- add the class' value table
	local valueTableId = nextID()
	local valueTableString = "local %s=setmetatable({static=%s"
	for enumName, id in pairs(enumIDs) do
		local tostringID = enumTostringIDs[enumName]
		valueTableString = valueTableString .. string.format(",%s=setmetatable(%s,{__index=%s,__newindex=%s,__tostring=function()return %s end})", enumName, id, functionErrorIDs.metatable.enum.index, functionErrorIDs.metatable.enum.newindex, tostringID)
	end
	add(valueTableString .. "},%s)", valueTableId, classStaticIDs[className], classMetatableMetatableID)

	local staticInitialiseStrings = {}
	-- setup the instance and static values and functions
	for mode, modeDetails in pairs({instance = classDetails.instance, static = classDetails.static}) do
		-- create the detault values
		local defaultValuesID = nextID()
		-- we need to collate all the places where default values are set and flatten it in to one table
		local flattenedDefaultValues = {}
		for i, superAllDetails in ipairs(supersDetails) do
			local superDetails = superAllDetails[mode]
			-- go through ourself and super
			for propertyName, defaultValue in pairs(superDetails.defaultValues) do
				-- first add the override default values
				if not flattenedDefaultValues[propertyName] then
					flattenedDefaultValues[propertyName] = defaultValue
				end
			end
			for propertyName, propertyDetails in pairs(superDetails.properties) do
				-- then try to get the default from the property definitions
				local defaultValue = propertyDetails.defaultValue
				if not flattenedDefaultValues[propertyName] then
					flattenedDefaultValues[propertyName] = defaultValue
				end
			end
		end
		add("local %s={", defaultValuesID)
		for propertyName, defaultValue in pairs(flattenedDefaultValues) do
			add("[%q]=loadstring(%q),", propertyName, "return " .. defaultValue)
		end
		add("}")

		-- add the functions
		local functionIDs = {}
		local functionsTable = "local %s={"
		local didAdd = false
		local allFunctionNames = {} -- all of the function names defined by us and the supers
		for functionName, functionDetails in pairs(modeDetails.functions) do
			-- add the actual function code
			local functionID = nextID()
			add("local function %s(self,super)return function%s end ", functionID, functionDetails[1])
			functionIDs[functionName] = functionID
		end
		classDetails[mode].functionIDs = functionIDs
		for i, superDetails in ipairs(supersDetails) do
			for functionName, id in pairs(superDetails[mode].functionIDs) do
				allFunctionNames[functionName] = true
			end
		end
		for functionName, _ in pairs(allFunctionNames) do
			-- create the functions table (the list of the function and all its supers)
			local functionsTableString = string.format("[%q]={", functionName)
			local isConsecutive = true
			for i, superDetails in ipairs(supersDetails) do
				local superFunctionID = superDetails[mode].functionIDs[functionName]
				if superFunctionID then
					-- this super class has another version of the same function
					if isConsecutive then
						functionsTableString = functionsTableString .. string.format("%s,", superFunctionID)
					else
						functionsTableString = functionsTableString .. string.format("[%d]=%s,", i, superFunctionID)
					end
				else
					isConsecutive = false
				end
			end
			functionsTable = functionsTable .. functionsTableString .. "},"
			didAdd = true
		end
		local functionsTableID
		if didAdd then
			functionsTableID = nextID()
			add(functionsTable:sub(1,#functionsTable - 1) .. "}", functionsTableID)
		end

		-- add the properties
		-- start the index metatable
		local propertyMethodIDs = {}
		-- as with default values, we need to collate all the places where properties are defined and flatten it in to one table
		local flattenedProperties = {}
		local flattenedPropertyMethods = {}
		for i = #supersDetails, 1, -1 do
			-- we need to go backwards because properties should only be defined ONCE (i.e. if it tries to override then error)
			local superDetails = supersDetails[i][mode]
			for propertyName, propertyDetails in pairs(superDetails.properties) do
				-- then try to get the default from the property definitions
				if flattenedProperties[propertyName] then
					error("compiler error: attempted to redeclare " .. mode .. " property '" .. propertyName .. " in " .. className .. " which was already defined by super class '" .. supersDetails[i].className .. "'. Subclasses are not allowed to change or redeclare properties defined by a super class.")
				else
					flattenedProperties[propertyName] = propertyDetails
				end
			end

			-- flatten all the property methods
			for methodName, methodDetails in pairs(superDetails.propertyMethods) do
				for propertyName, content in pairs(methodDetails) do
					if not flattenedPropertyMethods[propertyName] then
						flattenedPropertyMethods[propertyName] = {}
					end
					if not flattenedPropertyMethods[propertyName][methodName] then
						flattenedPropertyMethods[propertyName][methodName] = {[i] = content}
					else
						flattenedPropertyMethods[propertyName][methodName][i] = content
					end
				end
			end
		end
		-- add all the property method function code
		local propertyMethodIDs = {}
		for methodName, methods in pairs(classDetails[mode].propertyMethods) do
			for propertyName, methodDetails in pairs(methods) do
				if not propertyMethodIDs[propertyName] then
					propertyMethodIDs[propertyName] = {}
				end
				if methodName then
					local methodID = nextID()
					add("local function %s(self,super)return function%s end ", methodID, methodDetails[1])
					propertyMethodIDs[propertyName][methodName] = methodID
				end
			end
		end
		classDetails[mode].propertyMethodIDs = propertyMethodIDs

		-- create the super tree for property methods
		local propertyMethodsTables = {get = "get={", didSet = "didSet={", willSet = "willSet={", set = "set={"}
		local didAddTable = {get = false, didSet = false, willSet = false, set = false}
		for propertyName, methods in pairs(flattenedPropertyMethods) do
			propertyMethodsTableStrings = {get = string.format("[%q]={", propertyName), didSet = string.format("[%q]={", propertyName), willSet = string.format("[%q]={", propertyName), set = string.format("[%q]={", propertyName)}
			for methodName, methodDetails in pairs(methods) do
				local isConsecutive = true
				for i, superDetails in ipairs(supersDetails) do
					local superFunctionID = superDetails[mode].propertyMethodIDs[propertyName][methodName]
					if superFunctionID then
						-- this super class has another version of the same function
						if isConsecutive then
							propertyMethodsTableStrings[methodName] = propertyMethodsTableStrings[methodName] .. string.format("%s,", superFunctionID)
						else
							propertyMethodsTableStrings[methodName] = propertyMethodsTableStrings[methodName] .. string.format("[%d]=%s,", i, superFunctionID)
						end
					else
						isConsecutive = false
					end
				end
				propertyMethodsTables[methodName] = propertyMethodsTables[methodName] .. propertyMethodsTableStrings[methodName]:sub(1,#propertyMethodsTableStrings[methodName] - 1) .. "},"
				didAddTable[methodName] = true
			end
		end
		local propertyMethodsTable = "local %s={"
		didAdd = false
		for methodName, didAddMethod in pairs(didAddTable) do
			if didAddMethod then
				didAdd = true
				propertyMethodsTable = propertyMethodsTable .. propertyMethodsTables[methodName]:sub(1,#propertyMethodsTables[methodName] - 1) .. "},"
			end
		end
		local propertyMethodsTableID
		if didAdd then
			propertyMethodsTableID = nextID()
			add(propertyMethodsTable:sub(1,#propertyMethodsTable - 1) .. "}", propertyMethodsTableID)
		end

		-- create the super tree tables for all the property methods
		local flattenedPropertyMethodIDs = {}
		local propertyMethodIndicies = {}
		local index = 1
		for propertyName, properties in pairs(flattenedPropertyMethods) do
			flattenedPropertyMethodIDs[propertyName] = {}
			propertyMethodIndicies[propertyName] = {}
			for methodName, methods in pairs(properties) do
				local lastI = 0
				local didAddInner = false
				for superI, methodDetails in pairs(methods) do
					local superMethodID = supersDetails[superI][mode].propertyMethodIDs[propertyName]
					if superMethodID then
						superMethodID = superMethodID[methodName]
					end
					if superMethodID then
						if not flattenedPropertyMethodIDs[propertyName][methodName] then
							flattenedPropertyMethodIDs[propertyName][methodName] = superMethodID
							propertyMethodIndicies[superMethodID] = index
						end
					end
				end
			end
		end


		-- create the instance __index & __newindex methods for accessing properties and functions
		local instanceIndexTableID
		local instanceIndexTable = "local %s=setmetatable({"
		local instanceNewindexTableID
		local instanceNewindexTable = "local %s=setmetatable({"
		local didAdd = false
		for propertyName, propertyDetails in pairs(flattenedProperties) do
			local propertyMethods = flattenedPropertyMethods[propertyName]
			-- add the index method
			if propertyMethods and propertyMethods.get then
				-- there is a custom index property method
				instanceIndexTable = instanceIndexTable .. string.format("[%q]=function(_,k,v,g,l)", propertyName)
				instanceIndexTable = instanceIndexTable .. "if l[k]then return v[k]else l[k]=true "
				instanceIndexTable = instanceIndexTable .. "local v=g[k](_)l[k]=nil return v end end,"
			else
				-- there aren't any methods, we just need to return the value
				instanceIndexTable = instanceIndexTable .. string.format("[%q]=%s,", propertyName, functionBlankIndexID)
			end

			if propertyDetails.readOnly then
				instanceNewindexTable = instanceNewindexTable .. string.format("[%q]=%s,", propertyName, functionErrorIDs.readOnly)
			elseif propertyMethods and (propertyMethods.set or propertyMethods.didSet or propertyMethods.willSet) then
				instanceNewindexTable = instanceNewindexTable .. string.format("[%q]=function(_,k,n,v,w,s,d,l)", propertyName)
				-- TODO: add value checking
				--[[
					if __CLASS__type_check_String(value) then
						__CLASS__error_type_instance_property(self, key, "String", value)
					end
				]]
				instanceNewindexTable = instanceNewindexTable .. "if l[k]then v[k]=n else l[k]=true "
				if propertyMethods.willSet then
					instanceNewindexTable = instanceNewindexTable .. "w[k](_,n)"
				end
				if propertyMethods.set then
					instanceNewindexTable = instanceNewindexTable .. "s[k](_,n)"
				else
					instanceNewindexTable = instanceNewindexTable .. "v[k]=n "
				end
				if propertyMethods.didSet then
					instanceNewindexTable = instanceNewindexTable .. "d[k](_,n)"
				end
				instanceNewindexTable = instanceNewindexTable .. "l[k]=nil end end,"
			else
				-- there aren't any methods, we just need to set the value
				instanceNewindexTable = instanceNewindexTable .. string.format("[%q]=%s,", propertyName, functionBlankNewindexID)
			end
			didAdd = true
		end
		-- add the functions to the tables
		for functionName, _ in pairs(allFunctionNames) do
			instanceNewindexTable = instanceNewindexTable .. string.format("[%q]=%s,", functionName, functionErrorIDs.metatable.func.newindex)
			instanceIndexTable = instanceIndexTable .. string.format("[%q]=%s,", functionName, functionBlankIndexID)
		end
		if didAdd then
			instanceIndexTableID = nextID()
			instanceNewindexTableID = nextID()
			add(instanceIndexTable:sub(1,#instanceIndexTable - 1) .. "},%s)", instanceIndexTableID, instanceMetatableMetatableID)
			add(instanceNewindexTable:sub(1,#instanceNewindexTable - 1) .. "},%s)", instanceNewindexTableID, instanceMetatableMetatableID)
		else
			instanceIndexTableID, instanceNewindexTableID = instanceMetatableMetatableID, instanceMetatableMetatableID
		end

		-- add the instance variables
		local instanceVariablesID
		local instanceVariablesString = "local %s={"
		didAdd = false
		for variableName, content in pairs(classDetails[mode].instanceVariables) do
			instanceVariablesString = instanceVariablesString .. string.format("[%q]=loadstring([[return %s]]),", variableName, escapeSquare(content))
			didAdd = true
		end
		if didAdd then
			instanceVariablesID = nextID()
			add(instanceVariablesString:sub(1,#instanceVariablesString - 1) .. "}", instanceVariablesID)
		end

		-- create the typeof tree and the list of supers
		local typeOfTreeString = "local %s={"
		local superNamesID
		local superNamesString = "local %s={"
		didAdd = false
		-- add the base classes & static instance
		for i, superDetails in ipairs(supersDetails) do
			local superName = superDetails.className
			typeOfTreeString = typeOfTreeString .. string.format("[%s]=1,", superName)
			if mode == "static" then
				-- add the static instances
				typeOfTreeString = typeOfTreeString .. string.format("[%s]=1,", classStaticIDs[superName])
			end
			if i ~= 1 then
				superNamesString = superNamesString .. string.format("%q,", superName)
				didAdd = true
			end
		end
		local typeOfTreeID = nextID()
		add(typeOfTreeString:sub(1,#typeOfTreeString - 1) .. "}", typeOfTreeID)
		if didAdd then
			superNamesID = nextID()
			add(superNamesString:sub(1,#superNamesString - 1) .. "}", superNamesID)
		end

		-- add the class metatable
		if mode == "instance" then
			add("setmetatable(%s,{__index=%s,__newindex=%s,", className, valueTableId, functionErrorIDs.metatable.class.newindex)
			add("__call=function(_,...)return %s({},%q,%s,%s,%s,%s,%q,%s,%s,%s,%s,%s,...)end,", "__CLASS__instance_create", mode, instanceVariablesID, functionsTableID, defaultValuesID, fileEnvironmentIDs[classDetails.fileEnvironment], className, instanceIndexTableID, instanceNewindexTableID, superNamesID, propertyMethodsTableID, typeOfTreeID)
			add("__tostring=function()return %s end})", classTostringIDs[className])
		elseif mode == "static" then
			insert(staticInitialiseStrings, {"%s(%s,%q,%s,%s,%s,%s,%q,%s,%s,%s,%s,%s,...)","__CLASS__instance_create", classStaticIDs[className], mode, instanceVariablesID, functionsTableID, defaultValuesID, fileEnvironmentIDs[classDetails.fileEnvironment], className, instanceIndexTableID, instanceNewindexTableID, superNamesID, propertyMethodsTableID, typeOfTreeID})
		end
	end
	for i, str in ipairs(staticInitialiseStrings) do
		add(unpack(str))
	end
end

-- run the other code in the files inside their environments
for i, blocks in ipairs(fileEnvironments) do
	local id = fileEnvironmentIDs[i]
	for startLine, content in pairs(blocks) do
		if startLine ~= "fileName" then
			add("%s(%q,%d,setfenv(loadstring([[%s]]), %s))", functionErrorProxyID, blocks.fileName, startLine, escapeSquare(content), id)
		end
	end
end

print("Compile complete, saving...")
local h = io.open("output.lua", "w")
if h then
	h:write(file)
	h:close()
end
print("Saved. Compile complete.")
