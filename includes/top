dofile("serialise")

local function __CLASS__localise_functions(instance, funcs, instanceEnvironment, supers, supers__tostrings)
	local isFirst = true
	local superFuncs = {}
	local stack = {}
	local n = 1
	local f
	for superI, func in pairs(funcs) do
		if not isFirst then
			stack[n] = {superI, func}
			n = n + 1
		else
			f = func
			isFirst = false
		end
	end
	for i = n - 1, 1, -1 do
		local details = stack[i]
		local superI = details[1]
		local func = setfenv(details[2](supers[superI], superFuncs[i + 1]), instanceEnvironment)
		local super = superFuncs[i + 1]
		local __index
		if super then
			__index = function(_, k, v)
				if k == "super" then
					return super
				else
					__CLASS__7(_, k, v) -- __CLASS__error_function_super_no_index
				end
			end
		else
			__index = __CLASS__7
		end
		superFuncs[i] = setmetatable({}, {__index = __index, __newindex = __CLASS__8, __tostring = supers__tostrings[superI], __call = function(_, ...)return func(super, ...) end})
	end
	return setfenv(f(instance, superFuncs[1]), instanceEnvironment)
end

local __CLASS__instance_create = function(instance, instanceType, instanceVariables, instanceFunctions, defaultValues, defaultTypes, environmentClass, name, instance__index, instance__newindex, supers_names, propertyMethodFunctions, typeOfTree, ...)
	(instanceType == "static" and __CLASS__I or __CLASS__H)[instance] = typeOfTree -- instancesID/staticInstancesID
	local instanceEnvironment
	if instanceVariables then
		instanceEnvironment = setmetatable({}, {
			__index = function(_, k)
				if not instanceVariables[k] then -- if an instance variable is nil and there is an upvalue local with the same name the instance variable will hide the upvalue, even when nil
					return environmentClass[k]
				end
			end,
			__newindex = function(_, k, v)
				if not instanceVariables[k] then -- all instance variables hide upvalues, regardless of their value
					environmentClass[k] = v -- TODO: should this be the class environment, or _G?
				else
					rawset(_, k, v)
				end
			end
		})
		for k, v in pairs(instanceVariables) do
			instanceEnvironment[k] = __CLASS__F(v, environmentClass)
		end
	else
		instanceEnvironment = environmentClass
	end

	local values = {}
	local getLocks, setLocks = {}, {}
	local __tostring = instanceType .. " of '" .. name .. "': " .. tostring(instance):sub(8)
	local getMethods, willSetMethods, setMethods, didSetMethods = {}, {}, {}, {}
	setmetatable(instance, {
		__index = function(_,k)
			return instance__index[k](instance, k, values, getMethods, getLocks)
		end,
		__newindex = function(_,k,v)
			instance__newindex[k](instance, k, v, values, willSetMethods, setMethods, didSetMethods, setLocks)
		end,
		__tostring = function() return __tostring end
	})
	if defaultValues then
		for k,v in pairs(defaultValues) do
			local newValue = __CLASS__F(v, environmentClass)
			local neededType = defaultTypes[k]
			if neededType and neededType[1](newValue) then
				__CLASS__C(instance,k,neededType[2],newValue)
			end
			values[k] = newValue
		end
	end

	local supers = {}
	local supers__tostrings = {}
	local supersEnvironments = {}
	local supersValues = {}
	if supers_names then
		for i, super_name in ipairs(supers_names) do
			local super = {}
			-- local superValues = setmetatable({}, {__index = values, __newindex = function(_,k,v)values[k] = v end})
			local super__tostring = "super '" .. super_name .. "': " .. tostring(super):sub(8) .. " of " .. __tostring
			local super__tostring_func = function() return super__tostring end
			setmetatable(super, {
				__index = function(_,k)
					return instance__index[k](super, k, values, instanceEnvironment, getLocks)
				end,
				__newindex = function(_,k,v)
					instance__newindex[k](super, k, v, values, instanceEnvironment, setLocks)
				end,
				__tostring = super__tostring_func
			})
			supers[i +1] = super
			supers__tostrings[i +1] = super__tostring_func
		end
	end
	if propertyMethodFunctions then
		-- getMethods, willSetMethods, setMethods, didSetMethods = {}, {}, {}, {}
		local propertyMethods = {get = getMethods, willSet = willSetMethods, set = setMethods, didSet = didSetMethods}
		for methodName, properties in pairs(propertyMethodFunctions) do
			for propertyName, funcs in pairs(properties) do
				propertyMethods[methodName][propertyName] = __CLASS__localise_functions(instance, funcs, instanceEnvironment, supers, supers__tostrings)
			end
		end
	end


	if instanceFunctions then
		for k, funcs in pairs(instanceFunctions) do
			values[k] = __CLASS__localise_functions(instance, funcs, instanceEnvironment, supers, supers__tostrings)
		end
	end

	values.typeOf = function(_,other)
		return typeOfTree[other] == 1
	end

	local initialiseFunction = values.initialise
	if initialiseFunction then
		initialiseFunction(instance,...)
	end
	return instance
end

